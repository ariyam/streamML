/*
 * Based on the following paper:
 * P. Domingos and G. Hulten,  
 * "Mining  high-speed  data  streams",  
 * In  Proceedings  of  the  ACM  SIGKDD 2000. 
 * 
 * Description:
 * Each concept is generated by randomly creating a decision tree
 * following the guidelines in the paper.
 * 
 * @author: Ariyam Das
 */

import java.util.ArrayList;
import java.util.Random;

public class SyntheticConcept {
	
	final private int MIN_DEPTH = 3;	//from paper
	final private int MAX_DEPTH = 18;	//from paper
	final private int MAX_CHILDREN = 2;	//binary classes
	
	private int level;
	private int attribute;
	private int children_cnt;
	private int majority_class;
	private int [] edge_label;
	private SyntheticConcept [] children;
	private double conv_prob;	//probability of conversion
	
	public SyntheticConcept(int lev, ArrayList<Integer> unsel_attributes, double f)
	{
		this.level = lev;
		
		int cnt = unsel_attributes.size();
		Random rand = new Random();
		int id = rand.nextInt(cnt);
		this.attribute = unsel_attributes.get(id);
		unsel_attributes.remove(id);
		
		this.conv_prob = f;
		
		if(lev > MIN_DEPTH && (lev == MAX_DEPTH || Math.random() < conv_prob))	//convert this node into a leaf
		{
			this.children_cnt = 0;
			this.majority_class = rand.nextInt(MAX_CHILDREN);
			this.edge_label = null;
			this.children = null;
		}
		else	//persist this as a node
		{
			this.children_cnt = MAX_CHILDREN;
			this.majority_class = -1; //set -1 as this value is not required at all
			
			edge_label = new int[children_cnt];
			for(int i=0; i<children_cnt; i++)
				edge_label[i] = i;
			
			children = new SyntheticConcept[children_cnt];
			for(int i=0; i<children_cnt; i++)
			{
				ArrayList<Integer> rem_pool = new ArrayList<Integer>(unsel_attributes); //deep copy
				children[i] = new SyntheticConcept(level+1,rem_pool,conv_prob);
			}
		}	
	}
	
	public int getAttribute()
	{
		return this.attribute;
	}
	
	public int getLevel()
	{
		return this.level;
	}
	
	public int getChildrenCount()
	{
		return this.children_cnt;
	}
	
	public int getMajorityClass()
	{
		return this.majority_class;
	}
	
	public SyntheticConcept getChild(int edge)
	{
		int id = -1;
		for(int i=0; i<children_cnt; i++)
			if(edge_label[i]==edge)
			{
				id = i;
				break;
			}
		
		if(id!=-1)
			return children[id];
		else
			return null;
	}
	
	public SyntheticConcept getChildByIndex(int id)
	{
		if(id<children_cnt)
			return children[id];
		else
			return null;
	}
	
	public boolean isLeaf()
	{
		if(children_cnt==0)
			return true;
		else
			return false;
	}
	
	public long countNodes()
	{
		if(children_cnt==0)
			return 1;
		
		int res = 1;
		for(int i=0; i<children_cnt; i++)
			res += children[i].countNodes();
		return res;	
	}
	
	public long countLeaves()
	{
		if(children_cnt==0)
			return 1;
		
		int res = 0;
		for(int i=0; i<children_cnt; i++)
			res += children[i].countLeaves();
		return res;	
	}
	
	public void recursivePrintTree(SyntheticConcept node, int depth)
	{
		for(int i=0; i<depth; i++)	//tabs printed as per the depth
			System.out.print("\t");
		
		System.out.print("-" + node + "\n");	//print node
		
		for(int i=0; i<node.getChildrenCount(); i++)
		{
			SyntheticConcept tmp = node.getChildByIndex(i);
			recursivePrintTree(tmp, depth+1);	//recursively print its child
		}	
	}
	
	public void printTree()
	{
		recursivePrintTree(this,0);
	}
	
	public int classify(int pt[])
	{
		SyntheticConcept sc = this;		
		while(!sc.isLeaf())
		{
			int attr = sc.getAttribute();
			int e_val = pt[attr];
			sc = sc.getChild(e_val);		
		}	
		return sc.getMajorityClass();
	}
	
	public int randomClassify()
	{
		Random rand = new Random();
		return rand.nextInt(MAX_CHILDREN);
	}
	
	@Override
	public String toString()
	{
		String string = "";
		string = "Att:" + attribute + ", " + "Class:" + majority_class + ", " + "Lev:"+level + ", " + "Leaf:" + isLeaf();
		return string;
	}
	
	public static void main(String args[]) 
	{
		//pool of 100 binary attributes
		ArrayList<Integer> pool = new ArrayList<Integer>();
		for(int i=0; i<100; i++)
			pool.add(i);
		
		SyntheticConcept syncon = new SyntheticConcept(0,pool,0.25);
		
		System.out.println(syncon.countNodes());   //prints size of tree
		System.out.println(syncon.countLeaves());  //prints number of leaves
		//System.out.println(syncon);			     //prints root node
		//syncon.printTree();					     //prints entire tree
	}
}
